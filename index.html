<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>Hexo</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/atom.xml" class="header__link">RSS</a>
			
		</nav>
		<h1 class="header__title"><a href="/">Hexo</a></h1>
		<h2 class="header__subtitle">shuHalo-blog</h2>
	</header>

	<main>
		



	<article>
	
		<h1><a href="/2020/06/15/EventLoop/">EventLoop</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2020-06-15</span><br />
		
		
	</div>

	

	
		<h1 id="JS事件循环机制（event-loop）之宏任务-微任务-文章收藏"><a href="#JS事件循环机制（event-loop）之宏任务-微任务-文章收藏" class="headerlink" title="JS事件循环机制（event loop）之宏任务/微任务[文章收藏]"></a>JS事件循环机制（event loop）之宏任务/微任务[文章收藏]</h1><p>标签： eventloop 事件机制 node</p>
<hr>
<p>原文地址：<a target="_blank" rel="noopener" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly">Tasks, microtasks, queues and schedules</a></p>
<p>鉴于上篇文章有提到过 微任务与宏任务，所以，在此做个细致补充： 话不多说，直接进入正文：</p>
<blockquote>
<p>[1] 本文主要根据网上资源总结而来，如有不对，请斧正。 [2] 需要知道的专业名词术语：synchronous：同步任务、asynchronous：异步任务、task queue/callback queue：任务队列、execution context stack：执行栈、heap：堆、stack：栈、macro-task：宏任务、micro-task：微任务</p>
</blockquote>
<hr>
<h3 id="首先我们要知道两点："><a href="#首先我们要知道两点：" class="headerlink" title="首先我们要知道两点："></a>首先我们要知道两点：</h3><ul>
<li>JavaScript是单线程的语言</li>
<li>Event Loop是javascript的执行机制</li>
</ul>
<hr>
<h3 id="javascript事件循环"><a href="#javascript事件循环" class="headerlink" title="javascript事件循环"></a>javascript事件循环</h3><p>js是单线程，就像学生排队上厕所，学生需要排队一个一个上厕所，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p>
<ul>
<li>同步任务</li>
<li>异步任务</li>
</ul>
<p><figure class="figure"><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fa38dcffce?imageslim" alt="cmd-markdown-logo"><figcaption class="figure__caption">cmd-markdown-logo</figcaption></figure></p>
<p>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p>
<hr>
<p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制</p>
<h5 id="先看一段代码："><a href="#先看一段代码：" class="headerlink" title="先看一段代码："></a>先看一段代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;script start&#39;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#39;setTimeout&#39;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&#39;promise1&#39;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&#39;promise2&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;script end&#39;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>打印顺序是什么？ 正确答案是：script start, script end, promise1, promise2, setTimeout 已蒙圈。。。</p>
<h3 id="为什么会出现这样打印顺序呢？"><a href="#为什么会出现这样打印顺序呢？" class="headerlink" title="为什么会出现这样打印顺序呢？"></a>为什么会出现这样打印顺序呢？</h3><ul>
<li>如下导图（此图从网站下载）</li>
</ul>
<p><figure class="figure"><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fb89da87c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cmd-markdown-logo"><figcaption class="figure__caption">cmd-markdown-logo</figcaption></figure></p>
<p>解读：</p>
<ul>
<li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数</li>
<li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li>
<li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li>
<li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li>
</ul>
<p>我们不禁要问了，那怎么知道主线程执行栈为空呢？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p>
<p>看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let data &#x3D; [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;发送成功!&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;代码执行结束&#39;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面是一段简易的ajax请求代码：</p>
<ul>
<li>ajax进入Event Table，注册回调函数success。</li>
<li>执行console.log(‘代码执行结束’)。</li>
<li>ajax事件完成，回调函数success进入Event Queue。</li>
<li>主线程从Event Queue读取回调函数success并执行。</li>
</ul>
<p>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。</p>
<hr>
<h3 id="微任务-Microtasks-、宏任务-task-？"><a href="#微任务-Microtasks-、宏任务-task-？" class="headerlink" title="微任务(Microtasks)、宏任务(task)？"></a>微任务(Microtasks)、宏任务(task)？</h3><h5 id="微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event-Loop的走向和取值。那么他们之间到底有什么区别呢？"><a href="#微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event-Loop的走向和取值。那么他们之间到底有什么区别呢？" class="headerlink" title="微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。那么他们之间到底有什么区别呢？"></a>微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。那么他们之间到底有什么区别呢？</h5><p><figure class="figure"><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fa4b42e4af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cmd-markdown-logo"><figcaption class="figure__caption">cmd-markdown-logo</figcaption></figure></p>
<blockquote>
<p>一个掘金的老哥（ssssyoki）的文章摘要： 那么如此看来我给的答案还是对的。但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。 我当时看到这我就服了还有这种骚操作。</p>
</blockquote>
<ul>
<li>而宏任务一般是：包括整体代码script，setTimeout，setInterval、setImmediate。</li>
<li>微任务：原生Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver 记住就行了。</li>
<li><a target="_blank" rel="noopener" href="http://nodejs.cn/api/process.html">process是什么？</a></li>
</ul>
<hr>
<p>不废话，看以下例子：</p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;延时3秒&#39;);</span><br><span class="line">&#125;,3000)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;,3000)</span><br><span class="line">console.log(&#39;执行console&#39;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行console</span><br><span class="line">&#x2F;&#x2F; task()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>去验证一下，结果正确！ 然后我们修改一下前面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,3000)</span><br><span class="line"></span><br><span class="line">sleep(10000000)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解<code>setTimeout</code>的定义。我们先说上述代码是怎么执行的：</p>
<ul>
<li>task()进入Event Table并注册,计时开始。</li>
<li>执行sleep函数，很慢，非常慢，计时仍在继续。</li>
<li>3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。</li>
<li>sleep终于执行完了，task()终于从Event Queue进入了主线程执行。</li>
</ul>
<p>上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p>
<hr>
<p>我们还经常遇到<code>setTimeout(fn,0)</code>这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，<code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;代码1</span><br><span class="line">console.log(&#39;先执行这里&#39;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;执行啦&#39;)</span><br><span class="line">&#125;,0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代码2</span><br><span class="line">console.log(&#39;先执行这里&#39;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;执行啦&#39;)</span><br><span class="line">&#125;,3000);</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>代码1的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先执行这里</span><br><span class="line">执行啦</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>代码2的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先执行这里</span><br><span class="line">&#x2F;&#x2F; ... 3s later</span><br><span class="line">&#x2F;&#x2F; 执行啦</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。</p>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p>上面说完了<code>setTimeout</code>，当然不能错过它的孪生兄弟<code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p>
<p>唯一需要注意的一点是，<code>对于setInterval(fn,ms)</code>来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。</p>
<h3 id="Promise与process-nextTick-callback"><a href="#Promise与process-nextTick-callback" class="headerlink" title="Promise与process.nextTick(callback)"></a>Promise与process.nextTick(callback)</h3><ul>
<li>Promise的定义和功能本文不再赘述，可以学习一下 <a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/promise">阮一峰老师的Promise</a></li>
<li>而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</li>
</ul>
<h5 id="不同类型的任务会进入对应的Event-Queue，比如setTimeout和setInterval会进入相同的Event-Queue。"><a href="#不同类型的任务会进入对应的Event-Queue，比如setTimeout和setInterval会进入相同的Event-Queue。" class="headerlink" title="不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。"></a>不同类型的任务会进入对应的Event Queue，比如<code>setTimeout</code>和<code>setInterval</code>会进入相同的Event Queue。</h5><p>看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;setTimeout1&#39;)</span><br><span class="line">&#125;,0)</span><br><span class="line">let p &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;Promise1&#39;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">p.then(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;Promise2&#39;)    </span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h5 id="最后输出结果是Promise1，Promise2，setTimeout1"><a href="#最后输出结果是Promise1，Promise2，setTimeout1" class="headerlink" title="最后输出结果是Promise1，Promise2，setTimeout1"></a>最后输出结果是Promise1，Promise2，setTimeout1</h5><p>Promise参数中的Promise1是同步执行的 其次是因为Promise是microtasks，会在同步任务执行完后会去清空microtasks queues， 最后清空完微任务再去宏任务队列取值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;Promise1&#39;)  </span><br><span class="line">  setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;setTimeout2&#39;)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;setTimeout1&#39;)</span><br><span class="line">  Promise.resolve().then(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;Promise2&#39;)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,0)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h5 id="这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2"><a href="#这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2" class="headerlink" title="这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2"></a>这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2</h5><ul>
<li>一开始执行栈的同步任务执行完毕，会去 microtasks queues 找 清空 microtasks queues ，输出<code>Promise1</code>，同时会生成一个异步任务 setTimeout1</li>
<li>去宏任务队列查看此时队列是 setTimeout1 在 setTimeout2 之前，因为setTimeout1执行栈一开始的时候就开始异步执行,所以输出 <code>setTimeout1</code></li>
<li>在执行setTimeout1时会生成Promise2的一个 microtasks ，放入 microtasks queues 中，接着又是一个循环，去清空 microtasks queues ，输出 <code>Promise2</code></li>
<li>清空完 microtasks queues ，就又会去宏任务队列取一个，这回取的是 <code>setTimeout2</code></li>
</ul>
<p>如下图：</p>
<p><figure class="figure"><img src="https://user-gold-cdn.xitu.io/2018/7/14/1649751a2eb3953f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><figcaption class="figure__caption">img</figcaption></figure></p>
<p>最后我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;1&#39;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#39;2&#39;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#39;3&#39;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#39;4&#39;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#39;5&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&#39;6&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#39;7&#39;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#39;8&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#39;9&#39;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#39;10&#39;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#39;11&#39;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#39;12&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>第一轮事件循环流程分析如下：</p>
<ul>
<li>整体script作为第一个宏任务进入主线程，遇到console.log，输出<code>1</code>。</li>
<li>遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为<code>setTimeout1</code>。</li>
<li>遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</li>
<li>遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为<code>then1</code>。</li>
<li>又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为<code>setTimeout2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th align="right">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout1</td>
<td align="right">process1</td>
</tr>
<tr>
<td>setTimeout2</td>
<td align="right">then1</td>
</tr>
</tbody></table>
<ul>
<li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了<code>1</code>和<code>7</code>。</li>
</ul>
<p>我们发现了process1和then1两个微任务。</p>
<ul>
<li>执行process1,输出<code>6</code>。</li>
<li>执行then1，输出<code>8</code>。</li>
</ul>
<p>好了，第一轮事件循环正式结束，这一轮的结果是输出<code>1，7，6，8</code>。那么第二轮时间循环从setTimeout1宏任务开始：</p>
<ul>
<li>首先输出<code>2</code>。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。</li>
<li>new Promise立即执行输出<code>4</code>，then也分发到微任务Event Queue中，记为then2</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th align="right">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout2</td>
<td align="right">process3</td>
</tr>
<tr>
<td></td>
<td align="right">then3</td>
</tr>
</tbody></table>
<ul>
<li>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。</li>
<li>输出<code>10</code>。</li>
<li>输出<code>12</code>。</li>
<li>第三轮事件循环结束，第三轮输出<code>9，11，10，12</code>。</li>
<li>整段代码，共进行了三次事件循环，完整的输出为<code>1，7，6，8，2，4，3，5，9，11，10，12</code>。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</li>
</ul>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>希望大家看了本篇文章都有收获 …</p>

	

	

</article>




	<article>
	
		<h1><a href="/2020/03/07/箭头函数无this指向问题处理/">箭头函数无this指向问题处理</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2020-03-07</span><br />
		
		
	</div>

	

	
		<p>最近在处理Vue的computed计算属性函数问题的时候，发现一个有意思的现象，首先前提是因为我想将代码全部改为箭头函数进行简化，压缩成一行代码，然后也因为箭头函数的this的指向问题导致此时无法直接获取Vue这个实例，从而无法直接获得实例的data中的属性数据，在尝试解决办法过程中，将computed的函数形参随意填了一个名称，然后在函数作用域内该形参可以代替vue这个实例对象，从中可以拿到data中的所有属性<br>数据，目前还没有发现这个现象的具体原理，以及是否能够合理地使用，但是从效果上来，也能够基本实现代替this来指向实例对象获取属性数据，后续会继续发掘一下其中的原因。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:#app,</span><br><span class="line">    data:&#123;</span><br><span class="line">      allChannelList：[],</span><br><span class="line">      channel:[]</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="comment">//没有简写的函数channelRecomList</span></span><br><span class="line">  channelRecomList () &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.allChannelList.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">this</span>.channel.findIndex(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> v.id === item.id</span><br><span class="line">        &#125;) === -<span class="number">1</span></span><br><span class="line">       &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//简写的函数channelRecomList，使用箭头函数方法简化</span></span><br><span class="line">#注意：因箭头函数没有this指向，此时可以在channelRecomList函数中</span><br><span class="line">自定义形参，函数体内使用此形参代替<span class="built_in">this</span>指向来使用，如onThis，可</span><br><span class="line">以无定义，它本身代表全局的<span class="built_in">this</span>指向，解决箭头函数无<span class="built_in">this</span>指向的问题</span><br><span class="line">  channelRecomList: <span class="function">(<span class="params">onThis</span>) =&gt;</span> onThis.allChannelList.filter(<span class="function"><span class="params">item</span> =&gt;</span> onThis.channel.findIndex(<span class="function"><span class="params">v</span> =&gt;</span> v.id === item.id) === -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
	

	

</article>




	<article>
	
		<h1><a href="/2019/12/02/节流和防抖/">节流和防抖</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-12-02</span><br />
		
		
	</div>

	

	
		<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</p>
<p>场景: 搜索输入框</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>节流：指定时间间隔内只会执行一次任务。</p>
<p>场景：1. 监听滚动条 2. 监听点击按钮</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    canRun = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
	

	

</article>




	<article>
	
		<h1><a href="/2019/08/07/Vue中父组件调子组件事件的两种方法/">Vue中父组件调子组件事件的两种方法</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-08-07</span><br />
		
		
	</div>

	

	
		<p>首先明确需要使用到的方法<code>$on</code>和<code>$emit</code></p>
<p>vm.<code>$on</code>( event, callback )：监听当前实例上的自定义事件。事件可以由vm.<code>$emit</code>触发。回调函数会接收所有传入事件触发函数的额外参数。</p>
<p>vm.<code>$emit</code>( event, […args] )：触发当前实例上的事件。附加参数都会传给监听器回调。<br>父组件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;click&quot;</span>&gt;</span>点击父组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&quot;./child&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$refs.child.$emit(<span class="string">&#x27;childMethod&#x27;</span>,<span class="string">&#x27;发送给方法一的数据&#x27;</span>) <span class="comment">// 方法1:触发监听事件</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$refs.child.callMethod() <span class="comment">// 方法2:直接调用</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            child,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件中:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.monitoring() <span class="comment">// 注册监听事件</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">monitoring</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 监听事件</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$on(<span class="string">&#x27;childMethod&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">&#x27;方法1:触发监听事件监听成功&#x27;</span>)</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(res)</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">callMethod</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;方法2:直接调用调用成功&#x27;</span>)</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>触发父组件的click事件</p>
<p><figure class="figure"><img src="https://upload-images.jianshu.io/upload_images/17849217-5a2d55072dc0bb3a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1031/format/webp" alt="img"><figcaption class="figure__caption">img</figcaption></figure></p>
<p>调用成功</p>

	

	

</article>




	<article>
	
		<h1><a href="/2019/01/22/关于Vue路由过渡/">关于Vue路由过渡</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-01-22</span><br />
		
		
	</div>

	

	
		<h1 id="Vue-路由过渡"><a href="#Vue-路由过渡" class="headerlink" title="Vue 路由过渡"></a>Vue 路由过渡</h1><p><code>&lt;router-view&gt;</code> 是基本的动态组件，所以我们可以用 <code>&lt;transition&gt;</code> 组件给它添加一些过渡效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;transition name&#x3D;&quot;slide-left&quot; mode&#x3D;&quot;out-in&quot;&gt;</span><br><span class="line">        &lt;router-view &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;transition&gt;</span><br></pre></td></tr></table></figure>

<h3 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h3><p>在进入/离开的过渡中，会有 6 个 class 切换。</p>
<ol>
<li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>
<li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-enter-to</code>: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li>
<li><code>v-leave</code>: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li>
<li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-leave-to</code>: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。<figure class="figure"><img src="https://cn.vuejs.org/images/transition.png" alt="Transition Diagram"><figcaption class="figure__caption">Transition Diagram</figcaption></figure></li>
</ol>
<p>对于这些在过渡中切换的类名来说，如果使用一个没有名字的 <code>&lt;transition&gt;</code>，则 <code>v-</code> 是这些类名的默认前缀。如果你使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code>，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>。</p>
<p><strong>Props：</strong></p>
<ul>
<li><code>name</code> - string，用于自动生成 CSS 过渡类名。例如：<code>name: &#39;fade&#39;</code> 将自动拓展为<code>.fade-enter</code>，<code>.fade-enter-active</code>等。默认类名为 <code>&quot;v&quot;</code></li>
<li><code>appear</code> - boolean，是否在初始渲染时使用过渡。默认为 <code>false</code>。</li>
<li><code>css</code> - boolean，是否使用 CSS 过渡类。默认为 <code>true</code>。如果设置为 <code>false</code>，将只通过组件事件触发注册的 JavaScript 钩子。</li>
<li><code>type</code> - string，指定过渡事件类型，侦听过渡何时结束。有效值为 <code>&quot;transition&quot;</code> 和 <code>&quot;animation&quot;</code>。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</li>
<li><code>mode</code> - string，控制离开/进入过渡的时间序列。有效的模式有 <code>&quot;out-in&quot;</code> 和 <code>&quot;in-out&quot;</code>；默认同时进行。</li>
<li><code>duration</code> - number | { <code>enter</code>: number, <code>leave</code>: number } 指定过渡的持续时间。默认情况下，Vue 会等待过渡所在根元素的第一个 <code>transitionend</code> 或 <code>animationend</code> 事件。</li>
</ul>
<p><strong>过渡模式mode：</strong></p>
<p>​      1.in-out:新元素先进入过渡，完成之后当前元素过渡离开。</p>
<p>​      2.out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。</p>
<h5 id="example："><a href="#example：" class="headerlink" title="example："></a>example：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.slide-left-enter &#123;</span><br><span class="line">   opacity: 0;</span><br><span class="line">   -webkit-transform: translate(30px, 0);</span><br><span class="line">   transform: translate(30px, 0);</span><br><span class="line"> &#125;</span><br><span class="line"> .slide-left-enter-active&#123;</span><br><span class="line">   transition: all .5s ease;</span><br><span class="line"> &#125;</span><br><span class="line"> .slide-left-leave-to&#123;</span><br><span class="line">   opacity: 0;</span><br><span class="line">   -webkit-transform: translate(-30px, 0);</span><br><span class="line">   transform: translate(-30px, 0);</span><br><span class="line"> &#125;</span><br><span class="line"> .slide-left-leave-active &#123;</span><br><span class="line">   transition: all .5s ease;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





	

	

</article>




	<article>
	
		<h1><a href="/2018/10/03/深度作用选择器/">深度作用选择器</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2018-10-03</span><br />
		
		
	</div>

	

	
		<h1 id="vue-scoped-深度作用选择器"><a href="#vue-scoped-深度作用选择器" class="headerlink" title="vue scoped 深度作用选择器"></a>vue scoped 深度作用选择器</h1><p>如果希望 <code>scoped</code> 样式中的一个选择器能够作用得“更深”，例如影响子组件，可以使用 <code>&gt;&gt;&gt;</code> 操作符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.a &gt;&gt;&gt; .b &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<p>上述代码将会编译成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.a[data-v-f3f3eg9] .b &#123; &#x2F;* ... *&#x2F; &#125;</span><br></pre></td></tr></table></figure>



<p>有些像 Sass 之类的预处理器无法正确解析 <code>&gt;&gt;&gt;</code>。这种情况下可以使用 <code>/deep/</code> 操作符取而代之——这是一个 <code>/deep/</code> 或 <code>::v-deep</code> 操作符，同样可以正常工作。</p>
<p><strong>less使用/deep/</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=<span class="string">&quot;less&quot;</span> scoped&gt;</span><br><span class="line"></span><br><span class="line">.searchforminline-out &#123;</span><br><span class="line">/deep/ input&#123;</span><br><span class="line">width: <span class="number">50</span>px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



	

	

</article>




	<article>
	
		<h1><a href="/2018/05/29/知识点整理（5-30）/">知识点整理（5.29）</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2018-05-29</span><br />
		
		
	</div>

	

	
		<h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><p>块级格式化上下文，一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可：<br>1、float的值不是none。<br>2、position的值不是static或者relative。<br>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex<br>4、overflow的值不是visible<br>BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列<br>举例：两个相邻块级盒子垂直外边距合并问题</p>
<h4 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h4><p>rem是CSS3新增的一个相对单位（root em，根em），是一个相对单位，相对于当前html的font-size的大小来决定的，也就是1个REM = 当前html font-size大小；一般用来做移动端适配问题</p>
<h4 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h4><p>CSS 的预处理框架，在stylus里面可以写一些负责的逻辑，向判断，循环等，使用起来比较的简单方便，但是目前使用人群较少，基数基本上在Less&amp;Sass上面</p>

	

	

</article>




	<article>
	
		<h1><a href="/2018/04/20/知识点整理（4-20）/">知识点整理（4.20）</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2018-04-20</span><br />
		
		
	</div>

	

	
		<h4 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h4><p>postcss 一种对css编译的工具，类似babel对js的处理，常见功能：<br>1、使用下一代css语法<br>2、自动补全浏览器前缀<br>3、自动把px代为转换成rem<br>4、css 代码压缩等等<br>postcss 只是一个工具，本身不会对css一顿操作，它通过插件实现功能，autoprefixer 就是其一，我们可以在webpack里面进行相应配置；大致实现原理：<br>1、Tokenizer 将源css字符串进行分词<br>2、Parser 经过Tokenizer之后，需要Parser将结果初始化为AST 语法树<br>3、Processor 经过AST之后，PostCSS提供了大量JS API给插件用<br>4、Stringifier 插件处理后，比如加浏览器前缀，会被重新Stringifier.stringify为一般CSS</p>
<h4 id="async-awat"><a href="#async-awat" class="headerlink" title="async/awat"></a>async/awat</h4><p>1、async/await 是ES7出现的， 两者成对出现，有async地方不一定有await，但是有await地方，这个函数必须是async<br>2、async修饰过的函数，返回的是一个Promise对象，如果在函数中return一个数据，那么async会把这个通过 Promise.resolve() 封装成一个Promise对象<br>3、 await 放置在Promise调用之前，await 强制后面点代码等待，直到Promise对象resolve，得到resolve的值作为await表达式的运算结果<br>4、简单说明实现原理：async、await 是 co 库的官方实现。也可以看作自带启动器的 generator 函数的语法糖。不同的是，async、await 只支持 Promise 和原始类型的值</p>
<h4 id="JS执行机制，EventLopper，宏任务-amp-微任务"><a href="#JS执行机制，EventLopper，宏任务-amp-微任务" class="headerlink" title="JS执行机制，EventLopper，宏任务&amp;微任务"></a>JS执行机制，EventLopper，宏任务&amp;微任务</h4><p>1、 JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务<br>2、 在异步任务里面分为了宏任务和微任务，那么会跟进不同的分类放入不同的异步队列中，那么在最后只调用的时候必然会有顺序，那么调用的顺序是 先执行 微任务，再执行宏任务<br>3、 宏任务分为： ①setInterval；②setTimeout；<br>4、 微任务分为： ①Promise；②process.nextTick()</p>
<h4 id="ES6继承-super关键字作用"><a href="#ES6继承-super关键字作用" class="headerlink" title="ES6继承 super关键字作用"></a>ES6继承 super关键字作用</h4><p>ES6利用 extends 进行继承，在constructor里面需要协商super()，作用是为了修改父类中的this指向，指向子类的实例对象，就相当于调用了 Father.prototype.constructor.call(this,…)</p>

	

	

</article>






	<span class="different-posts">📕 end of posts 📕</span>


	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br />welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2020 PshuHao | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
