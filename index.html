<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>Hexo</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/atom.xml" class="header__link">RSS</a>
			
		</nav>
		<h1 class="header__title"><a href="/">Hexo</a></h1>
		<h2 class="header__subtitle">shuHalo-blog</h2>
	</header>

	<main>
		



	<article>
	
		<h1><a href="/2020/06/15/EventLoop/">EventLoop</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2020-06-15</span><br />
		
		
	</div>

	

	
		<h1 id="JS事件循环机制（event-loop）之宏任务-微任务-文章收藏"><a href="#JS事件循环机制（event-loop）之宏任务-微任务-文章收藏" class="headerlink" title="JS事件循环机制（event loop）之宏任务/微任务[文章收藏]"></a>JS事件循环机制（event loop）之宏任务/微任务[文章收藏]</h1><p>标签： eventloop 事件机制 node</p>
<hr>
<p>原文地址：<a target="_blank" rel="noopener" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly">Tasks, microtasks, queues and schedules</a></p>
<p>鉴于上篇文章有提到过 微任务与宏任务，所以，在此做个细致补充： 话不多说，直接进入正文：</p>
<blockquote>
<p>[1] 本文主要根据网上资源总结而来，如有不对，请斧正。 [2] 需要知道的专业名词术语：synchronous：同步任务、asynchronous：异步任务、task queue/callback queue：任务队列、execution context stack：执行栈、heap：堆、stack：栈、macro-task：宏任务、micro-task：微任务</p>
</blockquote>
<hr>
<h3 id="首先我们要知道两点："><a href="#首先我们要知道两点：" class="headerlink" title="首先我们要知道两点："></a>首先我们要知道两点：</h3><ul>
<li>JavaScript是单线程的语言</li>
<li>Event Loop是javascript的执行机制</li>
</ul>
<hr>
<h3 id="javascript事件循环"><a href="#javascript事件循环" class="headerlink" title="javascript事件循环"></a>javascript事件循环</h3><p>js是单线程，就像学生排队上厕所，学生需要排队一个一个上厕所，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p>
<ul>
<li>同步任务</li>
<li>异步任务</li>
</ul>
<p><figure class="figure"><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fa38dcffce?imageslim" alt="cmd-markdown-logo"><figcaption class="figure__caption">cmd-markdown-logo</figcaption></figure></p>
<p>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p>
<hr>
<p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制</p>
<h5 id="先看一段代码："><a href="#先看一段代码：" class="headerlink" title="先看一段代码："></a>先看一段代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;script start&#39;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#39;setTimeout&#39;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&#39;promise1&#39;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&#39;promise2&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;script end&#39;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>打印顺序是什么？ 正确答案是：script start, script end, promise1, promise2, setTimeout 已蒙圈。。。</p>
<h3 id="为什么会出现这样打印顺序呢？"><a href="#为什么会出现这样打印顺序呢？" class="headerlink" title="为什么会出现这样打印顺序呢？"></a>为什么会出现这样打印顺序呢？</h3><ul>
<li>如下导图（此图从网站下载）</li>
</ul>
<p><figure class="figure"><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fb89da87c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cmd-markdown-logo"><figcaption class="figure__caption">cmd-markdown-logo</figcaption></figure></p>
<p>解读：</p>
<ul>
<li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数</li>
<li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li>
<li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li>
<li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li>
</ul>
<p>我们不禁要问了，那怎么知道主线程执行栈为空呢？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p>
<p>看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let data &#x3D; [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;发送成功!&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;代码执行结束&#39;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面是一段简易的ajax请求代码：</p>
<ul>
<li>ajax进入Event Table，注册回调函数success。</li>
<li>执行console.log(‘代码执行结束’)。</li>
<li>ajax事件完成，回调函数success进入Event Queue。</li>
<li>主线程从Event Queue读取回调函数success并执行。</li>
</ul>
<p>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。</p>
<hr>
<h3 id="微任务-Microtasks-、宏任务-task-？"><a href="#微任务-Microtasks-、宏任务-task-？" class="headerlink" title="微任务(Microtasks)、宏任务(task)？"></a>微任务(Microtasks)、宏任务(task)？</h3><h5 id="微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event-Loop的走向和取值。那么他们之间到底有什么区别呢？"><a href="#微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event-Loop的走向和取值。那么他们之间到底有什么区别呢？" class="headerlink" title="微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。那么他们之间到底有什么区别呢？"></a>微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。那么他们之间到底有什么区别呢？</h5><p><figure class="figure"><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fa4b42e4af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cmd-markdown-logo"><figcaption class="figure__caption">cmd-markdown-logo</figcaption></figure></p>
<blockquote>
<p>一个掘金的老哥（ssssyoki）的文章摘要： 那么如此看来我给的答案还是对的。但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。 我当时看到这我就服了还有这种骚操作。</p>
</blockquote>
<ul>
<li>而宏任务一般是：包括整体代码script，setTimeout，setInterval、setImmediate。</li>
<li>微任务：原生Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver 记住就行了。</li>
<li><a target="_blank" rel="noopener" href="http://nodejs.cn/api/process.html">process是什么？</a></li>
</ul>
<hr>
<p>不废话，看以下例子：</p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;延时3秒&#39;);</span><br><span class="line">&#125;,3000)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;,3000)</span><br><span class="line">console.log(&#39;执行console&#39;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行console</span><br><span class="line">&#x2F;&#x2F; task()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>去验证一下，结果正确！ 然后我们修改一下前面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,3000)</span><br><span class="line"></span><br><span class="line">sleep(10000000)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解<code>setTimeout</code>的定义。我们先说上述代码是怎么执行的：</p>
<ul>
<li>task()进入Event Table并注册,计时开始。</li>
<li>执行sleep函数，很慢，非常慢，计时仍在继续。</li>
<li>3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。</li>
<li>sleep终于执行完了，task()终于从Event Queue进入了主线程执行。</li>
</ul>
<p>上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p>
<hr>
<p>我们还经常遇到<code>setTimeout(fn,0)</code>这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，<code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;代码1</span><br><span class="line">console.log(&#39;先执行这里&#39;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;执行啦&#39;)</span><br><span class="line">&#125;,0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代码2</span><br><span class="line">console.log(&#39;先执行这里&#39;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;执行啦&#39;)</span><br><span class="line">&#125;,3000);</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>代码1的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先执行这里</span><br><span class="line">执行啦</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>代码2的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先执行这里</span><br><span class="line">&#x2F;&#x2F; ... 3s later</span><br><span class="line">&#x2F;&#x2F; 执行啦</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。</p>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p>上面说完了<code>setTimeout</code>，当然不能错过它的孪生兄弟<code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p>
<p>唯一需要注意的一点是，<code>对于setInterval(fn,ms)</code>来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。</p>
<h3 id="Promise与process-nextTick-callback"><a href="#Promise与process-nextTick-callback" class="headerlink" title="Promise与process.nextTick(callback)"></a>Promise与process.nextTick(callback)</h3><ul>
<li>Promise的定义和功能本文不再赘述，可以学习一下 <a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/promise">阮一峰老师的Promise</a></li>
<li>而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</li>
</ul>
<h5 id="不同类型的任务会进入对应的Event-Queue，比如setTimeout和setInterval会进入相同的Event-Queue。"><a href="#不同类型的任务会进入对应的Event-Queue，比如setTimeout和setInterval会进入相同的Event-Queue。" class="headerlink" title="不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。"></a>不同类型的任务会进入对应的Event Queue，比如<code>setTimeout</code>和<code>setInterval</code>会进入相同的Event Queue。</h5><p>看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;setTimeout1&#39;)</span><br><span class="line">&#125;,0)</span><br><span class="line">let p &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;Promise1&#39;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">p.then(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;Promise2&#39;)    </span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h5 id="最后输出结果是Promise1，Promise2，setTimeout1"><a href="#最后输出结果是Promise1，Promise2，setTimeout1" class="headerlink" title="最后输出结果是Promise1，Promise2，setTimeout1"></a>最后输出结果是Promise1，Promise2，setTimeout1</h5><p>Promise参数中的Promise1是同步执行的 其次是因为Promise是microtasks，会在同步任务执行完后会去清空microtasks queues， 最后清空完微任务再去宏任务队列取值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;Promise1&#39;)  </span><br><span class="line">  setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;setTimeout2&#39;)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;setTimeout1&#39;)</span><br><span class="line">  Promise.resolve().then(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;Promise2&#39;)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,0)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h5 id="这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2"><a href="#这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2" class="headerlink" title="这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2"></a>这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2</h5><ul>
<li>一开始执行栈的同步任务执行完毕，会去 microtasks queues 找 清空 microtasks queues ，输出<code>Promise1</code>，同时会生成一个异步任务 setTimeout1</li>
<li>去宏任务队列查看此时队列是 setTimeout1 在 setTimeout2 之前，因为setTimeout1执行栈一开始的时候就开始异步执行,所以输出 <code>setTimeout1</code></li>
<li>在执行setTimeout1时会生成Promise2的一个 microtasks ，放入 microtasks queues 中，接着又是一个循环，去清空 microtasks queues ，输出 <code>Promise2</code></li>
<li>清空完 microtasks queues ，就又会去宏任务队列取一个，这回取的是 <code>setTimeout2</code></li>
</ul>
<p>如下图：</p>
<p><figure class="figure"><img src="https://user-gold-cdn.xitu.io/2018/7/14/1649751a2eb3953f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><figcaption class="figure__caption">img</figcaption></figure></p>
<p>最后我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;1&#39;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#39;2&#39;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#39;3&#39;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#39;4&#39;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#39;5&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&#39;6&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#39;7&#39;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#39;8&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#39;9&#39;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#39;10&#39;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#39;11&#39;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#39;12&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>第一轮事件循环流程分析如下：</p>
<ul>
<li>整体script作为第一个宏任务进入主线程，遇到console.log，输出<code>1</code>。</li>
<li>遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为<code>setTimeout1</code>。</li>
<li>遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</li>
<li>遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为<code>then1</code>。</li>
<li>又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为<code>setTimeout2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th align="right">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout1</td>
<td align="right">process1</td>
</tr>
<tr>
<td>setTimeout2</td>
<td align="right">then1</td>
</tr>
</tbody></table>
<ul>
<li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了<code>1</code>和<code>7</code>。</li>
</ul>
<p>我们发现了process1和then1两个微任务。</p>
<ul>
<li>执行process1,输出<code>6</code>。</li>
<li>执行then1，输出<code>8</code>。</li>
</ul>
<p>好了，第一轮事件循环正式结束，这一轮的结果是输出<code>1，7，6，8</code>。那么第二轮时间循环从setTimeout1宏任务开始：</p>
<ul>
<li>首先输出<code>2</code>。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。</li>
<li>new Promise立即执行输出<code>4</code>，then也分发到微任务Event Queue中，记为then2</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th align="right">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout2</td>
<td align="right">process3</td>
</tr>
<tr>
<td></td>
<td align="right">then3</td>
</tr>
</tbody></table>
<ul>
<li>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。</li>
<li>输出<code>10</code>。</li>
<li>输出<code>12</code>。</li>
<li>第三轮事件循环结束，第三轮输出<code>9，11，10，12</code>。</li>
<li>整段代码，共进行了三次事件循环，完整的输出为<code>1，7，6，8，2，4，3，5，9，11，10，12</code>。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</li>
</ul>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>希望大家看了本篇文章都有收获 …</p>

	

	

</article>




	<article>
	
		<h1><a href="/2020/03/07/箭头函数无this指向问题处理/">箭头函数无this指向问题处理</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2020-03-07</span><br />
		
		
	</div>

	

	
		<p>最近在处理Vue的computed计算属性函数问题的时候，发现一个有意思的现象，首先前提是因为我想将代码全部改为箭头函数进行简化，压缩成一行代码，然后也因为箭头函数的this的指向问题导致此时无法直接获取Vue这个实例，从而无法直接获得实例的data中的属性数据，在尝试解决办法过程中，将computed的函数形参随意填了一个名称，然后在函数作用域内该形参可以代替vue这个实例对象，从中可以拿到data中的所有属性<br>数据，目前还没有发现这个现象的具体原理，以及是否能够合理地使用，但是从效果上来，也能够基本实现代替this来指向实例对象获取属性数据，后续会继续发掘一下其中的原因。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:#app,</span><br><span class="line">    data:&#123;</span><br><span class="line">      allChannelList：[],</span><br><span class="line">      channel:[]</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="comment">//没有简写的函数channelRecomList</span></span><br><span class="line">  channelRecomList () &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.allChannelList.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">this</span>.channel.findIndex(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> v.id === item.id</span><br><span class="line">        &#125;) === -<span class="number">1</span></span><br><span class="line">       &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//简写的函数channelRecomList，使用箭头函数方法简化</span></span><br><span class="line">#注意：因箭头函数没有this指向，此时可以在channelRecomList函数中</span><br><span class="line">自定义形参，函数体内使用此形参代替<span class="built_in">this</span>指向来使用，如onThis，可</span><br><span class="line">以无定义，它本身代表全局的<span class="built_in">this</span>指向，解决箭头函数无<span class="built_in">this</span>指向的问题</span><br><span class="line">  channelRecomList: <span class="function">(<span class="params">onThis</span>) =&gt;</span> onThis.allChannelList.filter(<span class="function"><span class="params">item</span> =&gt;</span> onThis.channel.findIndex(<span class="function"><span class="params">v</span> =&gt;</span> v.id === item.id) === -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
	

	

</article>




	<article>
	
		<h1><a href="/2019/12/02/节流和防抖/">节流和防抖</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-12-02</span><br />
		
		
	</div>

	

	
		<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</p>
<p>场景: 搜索输入框</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>节流：指定时间间隔内只会执行一次任务。</p>
<p>场景：1. 监听滚动条 2. 监听点击按钮</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    canRun = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
	

	

</article>




	<article>
	
		<h1><a href="/2019/08/07/Vue中父组件调子组件事件的两种方法/">Vue中父组件调子组件事件的两种方法</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-08-07</span><br />
		
		
	</div>

	

	
		<p>首先明确需要使用到的方法<code>$on</code>和<code>$emit</code></p>
<p>vm.<code>$on</code>( event, callback )：监听当前实例上的自定义事件。事件可以由vm.<code>$emit</code>触发。回调函数会接收所有传入事件触发函数的额外参数。</p>
<p>vm.<code>$emit</code>( event, […args] )：触发当前实例上的事件。附加参数都会传给监听器回调。<br>父组件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;click&quot;</span>&gt;</span>点击父组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&quot;./child&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$refs.child.$emit(<span class="string">&#x27;childMethod&#x27;</span>,<span class="string">&#x27;发送给方法一的数据&#x27;</span>) <span class="comment">// 方法1:触发监听事件</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$refs.child.callMethod() <span class="comment">// 方法2:直接调用</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            child,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件中:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.monitoring() <span class="comment">// 注册监听事件</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">monitoring</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 监听事件</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$on(<span class="string">&#x27;childMethod&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">&#x27;方法1:触发监听事件监听成功&#x27;</span>)</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(res)</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">callMethod</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;方法2:直接调用调用成功&#x27;</span>)</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>触发父组件的click事件</p>
<p><figure class="figure"><img src="https://upload-images.jianshu.io/upload_images/17849217-5a2d55072dc0bb3a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1031/format/webp" alt="img"><figcaption class="figure__caption">img</figcaption></figure></p>
<p>调用成功</p>

	

	

</article>




	<article>
	
		<h1><a href="/2019/07/16/Vue作用域插槽深入理解/">Vue作用域插槽深入理解</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-07-16</span><br />
		
		
	</div>

	

	
		<h1 id="深入理解vue中的slot与slot-scope-文章收藏"><a href="#深入理解vue中的slot与slot-scope-文章收藏" class="headerlink" title="深入理解vue中的slot与slot-scope [文章收藏]"></a>深入理解vue中的slot与slot-scope [文章收藏]</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和methods，data，computed等常用选项在使用频率、使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了vue的说明文档。</p>
<p>实际上，插槽的概念很简单，下面通过分三部分来讲。这三部分也是按照vue说明文档的顺序来写的。</p>
<p>进入这三部分之前，先让还没接触过插槽的同学对什么是插槽有一个简单的概念：<strong>插槽，也就是slot，是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。</strong> 实际上，一个slot最核心的两个问题在这里就点出来了，是<strong>显示不显示</strong>和<strong>怎样显示</strong>。</p>
<p>由于插槽是一块模板，所以，对于任何一个组件，从模板种类的角度来分，其实都可以分为<strong>非插槽模板</strong>和<strong>插槽模板</strong>两大类。 非插槽模板指的是<strong>html模板</strong>，比如‘div、span、ul、table’这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制；插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。<strong>但是插槽显示的位置却由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置</strong>。</p>
<h2 id="单个插槽-默认插槽-匿名插槽"><a href="#单个插槽-默认插槽-匿名插槽" class="headerlink" title="单个插槽 | 默认插槽 | 匿名插槽"></a>单个插槽 | 默认插槽 | 匿名插槽</h2><p>首先是单个插槽，<strong>单个插槽</strong>是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。</p>
<p>单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。</p>
<p>下面通过一个例子来展示。</p>
<p>父组件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这里是父组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tmpl&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单6<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这里是子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在这个例子里，因为父组件在里面写了html模板，那么子组件的<strong>匿名插槽</strong>这块模板就是下面这样。也就是说，子组件的匿名插槽被使用了，是被下面这块模板使用了。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tmpl&quot;</span>&gt;</span><br><span class="line">  &lt;span&gt;菜单<span class="number">1</span>&lt;/span&gt;</span><br><span class="line">  &lt;span&gt;菜单<span class="number">2</span>&lt;/span&gt;</span><br><span class="line">  &lt;span&gt;菜单<span class="number">3</span>&lt;/span&gt;</span><br><span class="line">  &lt;span&gt;菜单<span class="number">4</span>&lt;/span&gt;</span><br><span class="line">  &lt;span&gt;菜单<span class="number">5</span>&lt;/span&gt;</span><br><span class="line">  &lt;span&gt;菜单<span class="number">6</span>&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>最终的渲染结果如图所示：</p>
<p><figure class="figure"><img src="https://upload-images.jianshu.io/upload_images/17288715-7b2da234ac49c4dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/782/format/webp" alt="img"><figcaption class="figure__caption">img</figcaption></figure></p>
<p>image.png</p>
<figcaption style="display: block; text-align: center; font-size: 1rem; line-height: 1.6; color: rgb(144, 144, 144); margin-top: 2px;"></figcaption>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注：所有demo都加了样式，以方便观察。其中，父组件以灰色背景填充，子组件都以浅蓝色填充。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个<strong>具名插槽</strong>和<strong>单个插槽</strong>的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。</p>
<p>父组件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这里是父组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tmpl&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;up&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单6<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tmpl&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;down&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-6<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tmpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-&gt;1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-&gt;2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-&gt;3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-&gt;4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-&gt;5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-&gt;6<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">    // 具名插槽</span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;up&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这里是子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    // 具名插槽</span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;down&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    // 匿名插槽</span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>显示结果如图：</p>
<p><figure class="figure"><img src="https://upload-images.jianshu.io/upload_images/17288715-4c2bba0b3b3ffb97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/742/format/webp" alt="img"><figcaption class="figure__caption">img</figcaption></figure></p>
<p>image.png</p>
<figcaption style="display: block; text-align: center; font-size: 1rem; line-height: 1.6; color: rgb(144, 144, 144); margin-top: 2px;"></figcaption>

<p>可以看到，父组件通过html模板上的slot属性关联具名插槽。没有slot属性的html模板默认关联匿名插槽。</p>
<h2 id="作用域插槽-带数据的插槽"><a href="#作用域插槽-带数据的插槽" class="headerlink" title="作用域插槽 | 带数据的插槽"></a>作用域插槽 | 带数据的插槽</h2><p>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">匿名插槽</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">具名插槽</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;up&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>但是<strong>作用域插槽要求，在slot上面绑定数据</strong>。也就是你得写成大概下面这个样子。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;slot name=<span class="string">&quot;up&quot;</span> :data=<span class="string">&quot;data&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        data: [<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;wanwu&#x27;</span>,<span class="string">&#x27;zhaoliu&#x27;</span>,<span class="string">&#x27;tianqi&#x27;</span>,<span class="string">&#x27;xiaoba&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">   html模板</span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>写了，插槽就总得在浏览器上显示点东西，东西就是html该有的模样，没写，插槽就是空壳子，啥都没有。 OK，我们说有html模板的情况，就是父组件会往子组件插模板的情况，那到底插一套什么样的样式呢，这由父组件的html+css共同决定，但是这套样式里面的内容呢？</p>
<p>正因为作用域插槽绑定了一套数据，父组件可以拿来用。于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。</p>
<p>我们再来对比，作用域插槽跟单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件提供的模板一般要既包括样式又包括内容，上面的例子中，你看到的文字，“菜单1”，“菜单2”都是父组件自己提供的内容；而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）。</p>
<p>下面的例子，你就能看到，父组件提供了三种样式(分别是flex、ul、直接显示)，都没有提供数据，数据使用的都是子组件插槽自己绑定的那个数组（一堆人名的那个数组）。</p>
<p>父组件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这里是父组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第一次使用：用flex展示数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tmpl&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;item in user.data&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第二次使用：用列表展示数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in user.data&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第三次使用：直接显示数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">       &#123;&#123;user.data&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">      我就是模板</span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;child&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h3&gt;这里是子组件&lt;/h3&gt;</span><br><span class="line">    <span class="comment">// 作用域插槽</span></span><br><span class="line">    &lt;slot  :data=<span class="string">&quot;data&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        data: [<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;wanwu&#x27;</span>,<span class="string">&#x27;zhaoliu&#x27;</span>,<span class="string">&#x27;tianqi&#x27;</span>,<span class="string">&#x27;xiaoba&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>结果如图所示：</p>
<p><figure class="figure"><img src="https://upload-images.jianshu.io/upload_images/17288715-3f1b657499f85075.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/703/format/webp" alt="img"><figcaption class="figure__caption">img</figcaption></figure></p>
<p>image.png</p>

	

	

</article>




	<article>
	
		<h1><a href="/2019/03/26/Es6的set和map/">Es6的set和map</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-03-26</span><br />
		
		
	</div>

	

	
		<h1 id="Es6之set-amp-map"><a href="#Es6之set-amp-map" class="headerlink" title="Es6之set&amp;map"></a>Es6之set&amp;map</h1><p>​        Set ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。 // 例一var set = new Set([1, 2, 3, 4, 4]); […set] // [1, 2, 3, 4]var s = new Set(); [2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x)); for (let i of s) { console.log(i); } // 2 3 5 4 在Set内部，两个NaN是相等。两个对象总是不相等的。</p>
<p>​        可以用length来检测 四个操作方法： add(value)：添加某个值，返回Set结构本身。delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。has(value)：返回一个布尔值，表示该值是否为Set的成员。clear()：清除所有成员，没有返回值 set内部的元素可以遍历for…of… weakset WeakSet结构与Set类似，也是不重复的值的集合。 WeakSet和Set的区别： WeakSet的成员只能是对象，而不能是其他类型的值WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。Map Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 var m = new Map(); var o = {p: “Hello World”}; m.set(o, “content”) m.get(o) // “content” m.has(o) // true m.delete(o) // true m.has(o) // false 注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。 var map = new Map(); map.set([‘a’], 555); map.get([‘a’]) // undefined 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。 如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。 实例属性和方法：size、set、get、has、delete、clear 遍历方法：keys（）、values（）、entries（）、forEach（）</p>

	

	

</article>




	<article>
	
		<h1><a href="/2019/02/26/简述HTTP请求过程/">简述HTTP请求过程</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-02-26</span><br />
		
		
	</div>

	

	
		<h1 id="简述HTTP请求过程"><a href="#简述HTTP请求过程" class="headerlink" title="简述HTTP请求过程"></a>简述HTTP请求过程</h1><p>HTTP（HyperText Transfer Protocol）超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的<strong>应用层协议</strong>。HTTP 是一个简单的<strong>请求-响应</strong>协议，是<strong>客户端和服务端</strong>之间请求和应答的标准，它通常运行在 TCP（传输控制协议）之上，由统一资源标识符（Uniform Resource Identifiers，URI 包含 URL 和 URN ）来标识。</p>
<p>HTTP 通过使用浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。HTTP是万维网的数据通信的基础。</p>
<p><figure class="figure"><img src="https://mu-mu.cn/blog/wp-content/uploads/2020/08/HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B-1.jpg" alt="img"><figcaption class="figure__caption">img</figcaption></figure></p>
<p>以下是一个 HTTP 请求的完整过程：</p>
<p>0、<strong>URL匹配和DNS解析</strong>：<br>之前在简述 URL 中说过，当我们在浏览器中输入一段 URL 的时候，会通过<strong>一系列规则</strong>，匹配到相应的唯一资源，比如说：<a target="_blank" rel="noopener" href="http://mu-mu.cn/example/index.html%EF%BC%8C%E5%88%99%E6%98%AF%E5%91%8A%E8%AF%89%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87http%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%9C%A8mu-mu.cn%E8%BF%99%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%8C%E5%9C%A8%E9%BB%98%E8%AE%A4%E7%9A%8480%E7%AB%AF%E5%8F%A3%E4%B8%8B%EF%BC%8C%E5%9C%A8/example%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8C%E8%AF%B7%E6%B1%82index.html%E8%BF%99%E4%B8%AA%E8%B5%84%E6%BA%90%E3%80%82">http://mu-mu.cn/example/index.html，则是告诉浏览器，我们需要通过http协议，在mu-mu.cn这个服务端，在默认的80端口下，在/example目录下，请求index.html这个资源。</a></p>
<p>不过其实大家都不认mu-mu.cn这个域名，认的都是mu-mu.cn对应的IP地址，就像我知道你叫张三，但是能表明你身份的不是张三这个名字，而是你的身份证号码一样，域名的出现只是为了方便人们记忆和使用，但要让计算机识别，还需要通过DNS将域名解析到相应的IP地址。</p>
<p>1、<strong>建立TCP连接：三次握手</strong><br>HTTP是应用层协议，他的工作还需要数据层协议的支持，最常与它搭配的就是TCP协议（应用层、数据层是OSI七层模型中的，以后有机会会说到的）。TCP协议称为数据传输协议，是可靠传输，面向连接的，并且面向字节流的。<br><strong>面向连接</strong>：通信之前先建立连接，确保双方在线。<br><strong>可靠传输</strong>：在网络正常的情况下，数据不会丢失。<br><strong>面向字节流</strong>：传输灵活，但是TCP的传输存在粘包问题，没有明显的数据约定。<br>在正式发送请求之前，需要先建立TCP连接。建立TCP连接的过程简单地来说就是客户端和服务端之间发送三次消息来确保连接的建立，这个过程称为<strong>三次握手</strong>。</p>
<p>2、<strong>发送请求</strong><br>TCP连接建立完毕之后，客户端就可以向服务端发送请求报文来请求资源了。请求报文分为请求行、请求头、空行和请求体，服务端通过请求行和请求头中的内容获取客户端的信息，通过请求体中的内容获取客户端传过来的数据。</p>
<p>3、<strong>响应应答</strong><br>在接收到客户端发来的请求报文并且确认完毕之后，服务端会向客户端发送响应报文。响应报文由状态行、响应头、空行和响应体组成，服务端通过状态行和响应头告诉客户端请求的状态和如何对数据处理等信息，真正的数据则在响应体中传输给客户端。</p>
<p>关于请求报文和响应报文，我之前也简单地说到过。<a target="_blank" rel="noopener" href="https://mu-mu.cn/blog/index.php/2020/07/29/1645/">https://mu-mu.cn/blog/index.php/2020/07/29/1645/</a></p>
<p>4、<strong>断开TCP连接</strong><br>当请求完成后，还需断开TCP连接。断开的过程简单地说就算客户端和服务端之间发送四次信息来确保连接的断开，所以称为四次挥手。</p>
<p>以上就是一个HTTP请求的简单过程了，接来下再说一说HTTP请求的特性。</p>
<p>一、<strong>单向请求</strong><br>HTTP请求是单向的，是只能由客户端发起请求，由服务端响应的<strong>请求-响应模式</strong>。（如果你需要双向请求，可以用socket）</p>
<p>二、<strong>基于TCP协议</strong><br>HTTP是应用层协议，所以其数据传输部分是基于TCP协议实现的。</p>
<p>三、<strong>无状态</strong><br>HTTP请求是无状态的，即没有记忆功能，不能获取之前请求或响应的内容。起初这种简单的模式，能够加快处理速度，保证协议的稳定，但是随着应用的发展，这种无状态的模式会使我们的业务实现变得麻烦，比如说需要保存用户的登录状态，就得专门使用数据库来实现。于是乎，为了实现状态的保持，引入了Cookie技术来管理状态。</p>
<p>四、<strong>无连接</strong><br>HTTP协议不能保存连接状态，每次连接只处理一个请求，用完即断，从而达到节约传输时间、提高并发性。在TCP连接断开之后，客户端和服务端就像陌生人一样，下次再发送请求，就得重新建立连接了。有时候，当我们需要发送一段频繁的请求时，这种无连接的状态反而会耗费更多的请求时间（因为建立和断开连接本身也需要时间），于是乎，HTTP1.1中提出了持久连接的概念，可以在请求头中设置Connection: keep-alive来实现。</p>
<p>至此，HTTP协议完整的请求过程和特性就简单地介绍完了，继续学习吧！</p>

	

	

</article>




	<article>
	
		<h1><a href="/2019/01/22/关于Vue路由过渡/">关于Vue路由过渡</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-01-22</span><br />
		
		
	</div>

	

	
		<h1 id="Vue-路由过渡"><a href="#Vue-路由过渡" class="headerlink" title="Vue 路由过渡"></a>Vue 路由过渡</h1><p><code>&lt;router-view&gt;</code> 是基本的动态组件，所以我们可以用 <code>&lt;transition&gt;</code> 组件给它添加一些过渡效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;transition name&#x3D;&quot;slide-left&quot; mode&#x3D;&quot;out-in&quot;&gt;</span><br><span class="line">        &lt;router-view &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;transition&gt;</span><br></pre></td></tr></table></figure>

<h3 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h3><p>在进入/离开的过渡中，会有 6 个 class 切换。</p>
<ol>
<li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>
<li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-enter-to</code>: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li>
<li><code>v-leave</code>: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li>
<li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-leave-to</code>: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。<figure class="figure"><img src="https://cn.vuejs.org/images/transition.png" alt="Transition Diagram"><figcaption class="figure__caption">Transition Diagram</figcaption></figure></li>
</ol>
<p>对于这些在过渡中切换的类名来说，如果使用一个没有名字的 <code>&lt;transition&gt;</code>，则 <code>v-</code> 是这些类名的默认前缀。如果你使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code>，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>。</p>
<p><strong>Props：</strong></p>
<ul>
<li><code>name</code> - string，用于自动生成 CSS 过渡类名。例如：<code>name: &#39;fade&#39;</code> 将自动拓展为<code>.fade-enter</code>，<code>.fade-enter-active</code>等。默认类名为 <code>&quot;v&quot;</code></li>
<li><code>appear</code> - boolean，是否在初始渲染时使用过渡。默认为 <code>false</code>。</li>
<li><code>css</code> - boolean，是否使用 CSS 过渡类。默认为 <code>true</code>。如果设置为 <code>false</code>，将只通过组件事件触发注册的 JavaScript 钩子。</li>
<li><code>type</code> - string，指定过渡事件类型，侦听过渡何时结束。有效值为 <code>&quot;transition&quot;</code> 和 <code>&quot;animation&quot;</code>。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</li>
<li><code>mode</code> - string，控制离开/进入过渡的时间序列。有效的模式有 <code>&quot;out-in&quot;</code> 和 <code>&quot;in-out&quot;</code>；默认同时进行。</li>
<li><code>duration</code> - number | { <code>enter</code>: number, <code>leave</code>: number } 指定过渡的持续时间。默认情况下，Vue 会等待过渡所在根元素的第一个 <code>transitionend</code> 或 <code>animationend</code> 事件。</li>
</ul>
<p><strong>过渡模式mode：</strong></p>
<p>​      1.in-out:新元素先进入过渡，完成之后当前元素过渡离开。</p>
<p>​      2.out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。</p>
<h5 id="example："><a href="#example：" class="headerlink" title="example："></a>example：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.slide-left-enter &#123;</span><br><span class="line">   opacity: 0;</span><br><span class="line">   -webkit-transform: translate(30px, 0);</span><br><span class="line">   transform: translate(30px, 0);</span><br><span class="line"> &#125;</span><br><span class="line"> .slide-left-enter-active&#123;</span><br><span class="line">   transition: all .5s ease;</span><br><span class="line"> &#125;</span><br><span class="line"> .slide-left-leave-to&#123;</span><br><span class="line">   opacity: 0;</span><br><span class="line">   -webkit-transform: translate(-30px, 0);</span><br><span class="line">   transform: translate(-30px, 0);</span><br><span class="line"> &#125;</span><br><span class="line"> .slide-left-leave-active &#123;</span><br><span class="line">   transition: all .5s ease;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





	

	

</article>




	<article>
	
		<h1><a href="/2018/12/26/axios和ajax的区别/">axios和ajax的区别</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2018-12-26</span><br />
		
		
	</div>

	

	
		<h3 id="axios和ajax的区别"><a href="#axios和ajax的区别" class="headerlink" title="axios和ajax的区别"></a>axios和ajax的区别</h3><h3 id="1-Axios"><a href="#1-Axios" class="headerlink" title="1. Axios"></a>1. Axios</h3><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。<br>特点：<br>1.从浏览器中创建 XMLHttpRequests<br>2.从 node.js 创建 http 请求<br>3.支持 Promise API<br>4.拦截请求和响应<br>5.转换请求数据和响应数据<br>6.取消请求<br>7.自动转换 JSON 数据<br>8.客户端支持防御 XSRF</p>
<h3 id="2-AJAX"><a href="#2-AJAX" class="headerlink" title="2 . AJAX"></a>2 . AJAX</h3><p>AJAX 是与服务器交换数据并更新部分网页的，在不重新加载整个页面的情况下。<br>Ajax = 异步 JavaScript 和 XML（标准通用标记语言的子集）。</p>
<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><p>axios 和 ajax 的使用方法基本一样，只有<strong>个别参数不同</strong>；</p>
<p><strong>Axios</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">      url: <span class="string">&#x27;http://jsonplaceholder.typicode.com/users&#x27;</span>,</span><br><span class="line">      method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">      responseType: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// 默认的</span></span><br><span class="line">      data: &#123;</span><br><span class="line">        <span class="comment">//&#x27;a&#x27;: 1,</span></span><br><span class="line">        <span class="comment">//&#x27;b&#x27;: 2,</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).then(function (response) &#123;</span><br><span class="line">      console.log(response);</span><br><span class="line">      console.log(response.data);</span><br><span class="line">    &#125;).<span class="keyword">catch</span>(function (error) &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">      url: <span class="string">&#x27;http://jsonplaceholder.typicode.com/users&#x27;</span>,</span><br><span class="line">      type: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">      dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        <span class="comment">//&#x27;a&#x27;: 1,</span></span><br><span class="line">        <span class="comment">//&#x27;b&#x27;: 2,</span></span><br><span class="line">      &#125;,</span><br><span class="line">      success: function (response) &#123;</span><br><span class="line">        console.log(response)；</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>


	

	

</article>




	<article>
	
		<h1><a href="/2018/10/03/深度作用选择器/">深度作用选择器</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2018-10-03</span><br />
		
		
	</div>

	

	
		<h1 id="vue-scoped-深度作用选择器"><a href="#vue-scoped-深度作用选择器" class="headerlink" title="vue scoped 深度作用选择器"></a>vue scoped 深度作用选择器</h1><p>如果希望 <code>scoped</code> 样式中的一个选择器能够作用得“更深”，例如影响子组件，可以使用 <code>&gt;&gt;&gt;</code> 操作符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.a &gt;&gt;&gt; .b &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<p>上述代码将会编译成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.a[data-v-f3f3eg9] .b &#123; &#x2F;* ... *&#x2F; &#125;</span><br></pre></td></tr></table></figure>



<p>有些像 Sass 之类的预处理器无法正确解析 <code>&gt;&gt;&gt;</code>。这种情况下可以使用 <code>/deep/</code> 操作符取而代之——这是一个 <code>/deep/</code> 或 <code>::v-deep</code> 操作符，同样可以正常工作。</p>
<p><strong>less使用/deep/</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=<span class="string">&quot;less&quot;</span> scoped&gt;</span><br><span class="line"></span><br><span class="line">.searchforminline-out &#123;</span><br><span class="line">/deep/ input&#123;</span><br><span class="line">width: <span class="number">50</span>px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



	

	

</article>





	<span class="different-posts">📖 <a href="/page/2">more posts</a> 📖</span>



	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br />welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2020 PshuHao | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
